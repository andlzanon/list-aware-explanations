import os
from pathlib import Path

import pandas as pd
import pytest
import re

@pytest.mark.parametrize(
    "dataset, experiment",
    [
        ("hetrec2011-lastfm-2k", "experiment1"),
        ("ml-latest-small", "experiment1"),
        ("ml-latest-small", "experiment2")
    ]
)
def test_explanations(dataset: str, experiment: str):
    """
    Test to validate all samples explanations. An explanation to be validated must:
        (i) all interacted items should have all attributes shown on explanations
        (ii) all interacted items should have all attributes shown on explanations.
        Rule (ii) there is an exception for ExpLODRow algorithm when all_props=False. This means that
        the rule in this case is that at least one recommended item should have an attribute that appear on the
        recommendation
    have all attributes
    :param dataset: dataset to which explanations where generated
    :param experiment: explanation folder
    :return: True if all explanations for the experiment are valid, False otherwise
    """
    # get test dir and get the path to the explanations
    test_dir = Path(__file__).parent
    expl_folder = test_dir.parent / "datasets" / dataset / "stratified_split" / "explanations" / experiment

    # read KG
    if dataset == "ml-latest-small":
        prop_set = pd.read_csv(test_dir.parent / "knowledge-graphs" / "props_wikidata_movielens_small.csv")
    else:
        prop_set = pd.read_csv(test_dir.parent / "knowledge-graphs" / "props_artists_id.csv")

    # index by item name (column 1) that is used on explanations
    prop_set = prop_set.set_index(prop_set.columns[1])

    # for every algorithm on the experiment
    for filename in os.listdir(expl_folder):
        filepath = os.path.join(expl_folder, filename)

        if os.path.isfile(filepath):
            with open(filepath, 'r', encoding='utf-8') as file:
                # parse every line and get attributes (objs), hist items and rec items
                for line in file:
                    ret = parse_sentence(line.rstrip())
                    if sum([len(r) for r in ret]) > 0 and len(ret[0]) > 0:
                        objs = ret[0]
                        hist = ret[1]
                        rec = ret[2]
                        # check if all hist items have all obj
                        for h in hist:
                            df_h = prop_set.loc[h]
                            for obj in objs:
                                if df_h[df_h['obj'] == obj].shape[0] == 0:
                                    print(line.rstrip())
                                    assert False

                        # check if all rec have attribute if file is not ExpLODRows with all_props param = False
                        if "all_props=False" not in str(filepath):
                            for r in rec:
                                df_r = prop_set.loc[r]
                                for obj in objs:
                                    if df_r[df_r['obj'] == obj].shape[0] == 0:
                                        print(line.rstrip())
                                        assert False
                        # Otherwise check if at least one have the obj
                        else:
                            for obj in objs:
                                if len(set(prop_set[prop_set['obj'] == obj].index).intersection(set(rec))) == 0:
                                    print(line.rstrip())
                                    assert False

    assert True

def smart_split(text):
    """
    Split the line and treat exceptions
    :param text: string of terms separated by comma. E.g.: Titanic, Forrest Gump
    :return: splited text: [Titanic, Forrest Gump]
    """
    parts = re.split(', ', text)
    merged = []
    exceptions = ["Inc.", "Original Screenplay"]
    i = 0
    while i < len(parts):
        current = parts[i].strip()
        if i + 1 < len(parts) and any(exc in parts[i+1].strip() for exc in exceptions):
            merged.append(current + ', ' + parts[i+1].strip())
            i += 2
        else:
            merged.append(current)
            i += 1
    return merged

def parse_sentence(sentence: str):
    """
    Parsing function
    "If you are in the mood for musician, United States of America items, I recommend Green Day, The Doors"
    where we get the musician and United States of America, on a list and Green Day and The Doors on another.
    Another case is when there "such as" clauses. E.g.: "If you are in the mood for electronic rock items such
    as Matryoshka, I recommend Placebo, Depeche Mode, Daft Punk"
    Code generated by ChatGPT and changed by me.
    :param sentence: phrase to parse
    :return: tuple with the criteria, examples, recommendations
    """
    # 1. Match case: no criteria, just examples and recommendations
    match_no_criteria = re.search(
        r"mood for items, items such as (.+?), I recommend (.+)", sentence
    )
    if match_no_criteria:
        examples_str = match_no_criteria.group(1)
        recs_str = match_no_criteria.group(2)

        return [], smart_split(examples_str), smart_split(recs_str)

    # 2. Match case: criteria + examples + recommendations
    match_with_examples = re.search(
        r"mood for (.+?) items such as (.+?), I recommend (.+)", sentence
    )
    if match_with_examples:
        criteria_str = match_with_examples.group(1)
        examples_str = match_with_examples.group(2)
        recs_str = match_with_examples.group(3)

        return (
            smart_split(criteria_str),
            smart_split(examples_str),
            smart_split(recs_str)
        )

    # 3. Match case: criteria + recommendations only
    match_basic = re.search(r"mood for (.+?) items, I recommend (.+)", sentence)
    if match_basic:
        criteria_str = match_basic.group(1)
        recs_str = match_basic.group(2)

        return (
            smart_split(criteria_str),
            [],
            smart_split(recs_str)
        )

    # Fallback
    return [], [], []

